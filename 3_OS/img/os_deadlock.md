# 교착 상태(Deadlock)

- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태이다.
- 운영체제 또는 소프트웨어의 잘못된 자원(resource) 관리로 인하여 한정된 자원을 둘 이상의 프로세스 또는 스레드가 서로 동시에 사용하려고 기다리기 때문에 **아무것도 진행하지 않는 상태로 영원히 서로 대기**한다.
- 멀티스레딩, 병렬 프로그래밍, 분산 컴퓨팅에서 흔히 발생하는 문제이다.

## 발생 조건

- 교착 상태는 **네 가지 필요 조건**이 **동시에 충족**될 때 발생한다.

### 1. 상호배제(Mutual exclusion)

- 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
- 한 자원은 한 번에 하나의 프로세스만 사용 가능하다.
- 한 자원을 **동시에 사용할 수 없다**.

### 2. 점유대기(Hold and wait)

- 자원을 가진 프로세스가 다른 자원을 기다릴 때 **붙잡은 상태(hold)** 에서 다른 자원을 **기다린다(wait)**.

### 3. 비선점(No preemption)

- 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
- 자원 반환은 그 자원을 취득한 프로세스만 할 수 있다.

### 4. 순환대기(Circular wait)

- 각 프로세스는 다음 프로세스가 요구하는 자원을 가지고 있다.
- 사이클이 형성되어 **순환(circular)** 형태로 기다린다.

## 해결 방법

### 예방(Prevention)

- 네 가지 필요 조건중 하나를 만족하지 않게 하는 방식

1. 상호배제(Mutual exclusion) 조건 제거
   - 여러 프로세스가 동시에 공유 자원에 접근 가능
   - 그러나 경쟁 조건이나 일관성 문제에 대한 고려가 필요해진다.
2. 점유대기(Hold and wait) 조건 제거
   - 프로세스 실행 전 모든 자원 할당
     - 자원 낭비와 자원의 무기한 연기 발생 가능
   - 기아 상태(Starvation) : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생
3. 비선점(No preemption) 조건 제거
   - 선점 가능하게 만들어 점유중인 자원을 다른 프로세스가 요구하는 경우 반납 가능
4. 순환대기(Circular wait) 조건 제거
   - 자원에 순서를 매긴다.

### 회피(Avoidance)

- 시스템에서 자원 요청에 대한 부가적인 정보를 이용하여 Deadlock의 가능성이 없는 경우에만 자원을 할당
  - 현재 사용 가능한 자원, 이미 할당된 자원, 앞으로 있을 자원 요청이나 반환 등
- 은행원 알고리즘
  - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
  - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

### 탐지(Detection)

- 막는 것이 아닌 데드락이 필연적으로 발생할 것을 가정하고, 현재 시스템상에서 어느 부분에 데드락이 발생했는지를 탐색하는 방식
- 자원 할당 그래프를 통해 교착 상태를 탐지

### 복구(Recovery)

1. 프로세스 종료
   - 교착 상태인 프로세스를 종료
2. 자원 회수
   - 프로세스에 할당된 각 자원들을 데드락 현상이 사라질 때까지 강제로 회수하는 방법

### 무시(Ignorance)

- 예방 혹은 회피기법을 프로그래밍해서 넣으면 성능에 큰 영향을 미칠 수 있게 된다.
- 따라서 교착 상태를 시스템이 책임지지 않는다.
- 대부분의 OS가 채택한 방식
