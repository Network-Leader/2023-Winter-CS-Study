# 해시

### 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조입니다.

빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다.

각 Key 값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 하지만 index 값이 충돌한 경우 Chanining에 연결된 리스트까지 검색해야 하므로 O(n)까지 증가할 수 있습니다.

### Hash Map과 Hash Table의 차이점에 대해 설명해주세요.

동기화 지원 여부와 null 값 허용 여부의 차이.

병렬처리를 하면서 자원의 동기화를 고려해야 하는 상황이면 해시 테이블을 사용해야하며 (Thread-safe), 해시 테이블은 null 값을 허용하지 않습니다.

병렬처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 해시 맵을 사용할 수 있고 (Thread-safe하지 않는다), null 값을 허용합니다.

## 해시(Hash)

### 정의

해시(Hash)는 입력 데이터를 고정된 길이의 데이터로 변환된 값을 말합니다.

### 해싱

'해싱 함수(Hashing Functoin)'는 **키(key)** 를 받아서 정수 값인 '해시 코드'를 반환하고,

반환된 해시 코드는 Hash 배열의 각 요소인 '버킷(Bucket)'의 인덱스가 된다.

![hash.png](img%2Fhash.png)

### 특징

- 키(KEY)에 데이터(Value)를 매핑할 수 있는 데이터 구조
- 해시 함수를 통해 키의 데이터를 배열에 저장할 수 있는 주소(인덱스 번호)를 계산
- 데이터의 순서가 중요하지 않고, 키를 기반으로 빠른 데이터 액세스가 필요할 때 사용하면 좋다.
- 충돌이 없는 일반적인 경우는 O(1). 최악의 경우(모든 index에서 충돌이 발생할 경우) O(n)

### **Hash Table**

해시 테이블(Hash table)은 키와 값을 함께 저장해 둔 데이터 구조입니다. 테이블에 데이터를 저장할 때 위치는 무작위로 지정되어 작성됩니다. 따라서 중간에 여유 공간이 발생할 수 있습니다.

**장점**

1. 적은 리소스로 많은 데이터를 효율적으로 관리
2. 배열의 인덱스(index)를 사용해서 검색, 삽입, 삭제가 빠르다. (평균 시간복잡도 : O(1))
    - 인덱스를 사용해서 배열의 검색이 빠르다는 것은 당연한 소리이다. 하지만 삽입, 삭제는 왜 O(1)인가?
    - 여기서의 인덱스는 데이터만의 고유한 위치이기 때문에 만약 삽입이나 삭제를 한다고 해도 다른 데이터로 채울 필요가 없다. 즉, 삽입이나 삭제할 때 데이터를 이동할 필요가 없기 때문이다.
3. 키(key)와 해시값(Hash)이 연관성이 없어 보안에도 많이 사용
4. 데이터 캐싱(Data Caching)에 많이 사용된다.
5. 중복을 제거하는데 유용

**단점**

1. 충돌
2. 공간 복잡도가 커진다.
3. 순서가 있는 배열에는 어울리지 않는다.
4. 해시 함수 의존도가 높아진다.

### Hash Map과의 차이

Java에서 HashTable과 HashMap의 차이는 동기화 지원 여부이다. 키(Key)에 대한 해시(Hash)값을 사용하여 값을 저장, 조회 하는 것은 동일

- **해시 테이블(Hash Table)**
    - 병렬 처리를 할 때 (동기화를 고려해야하는 상황)
    - Null 값을 허용하지 않는다.
- **해시 맵(Hash Map)**
    - 병렬 처리를 하지 않을 때 (동기화를 고려하지 않는 상황)
    - Null 값을 허용한다.

### H**ash function**

입력받은 데이터를 해시 값으로 출력시키는 알고리즘.
저장되는 값들의 key 값을 hash function을 통해서 **작은 범위의 값들로** 바꿔준다.

## **Collision**

**두 개 이상의 키가 동일한 해시 코드를 가질 때 충돌이 발생.** 같은 인덱스로 hashing되는 현상

1. 함수 알고리즘의 성능이 좋지 못한 경우
2. 저장되는 데이터 양이 해시 테이블의 크기(Size) 보다 클 경우

### Chaining

- 각 버킷을 연결 리스트로 구현
- 충돌이 발생하면, 해당 버킷의 연결 리스트에 새로운 키-값 쌍을 추가
- 구현이 간단하고, 메모리가 동적으로 할당

### **개방 주소법 (Open Addressing)**

- 모든 키-값 쌍이 해시 테이블의 배열 내에 직접 저장
- 충돌이 발생하면, 다른 버킷의 위치를 찾아 삽입을 시도
- **"다른 위치를 찾는"** 과정은 또 여러 방법으로 나뉨
    - 선형 조사 (Linear Probing) : 초기 위치에서 일정 간격으로 버킷을 조사하여 빈 위치를 찾는다.
    - 제곱 조사 (Quadratic Probing) : 충돌 발생 시 제곱만큼 떨어진 위치를 조사한다.
    - 이중 해싱 (Double Hashing) : 두 번째 해시 함수를 사용하여 버킷 위치를 찾는다.

### 재해싱 (Rehashing)

- 해시 테이블이 가득 차거나 충돌이 너무 많이 발생할 경우, 해시 테이블의 크기를 늘리고 모든 키-값 쌍을 새로운 크기에 맞게 재삽입하는 방법
- 이 방법은 메모리 사용량을 늘리는 대신 충돌을 줄이고 성능을 향상시키는 데 효과적

### 버킷 확장 (Bucket Expansion)

- 충돌이 일어나면 해당 버킷의 크기를 확장하여 여러 키-값 쌍을 저장

### 커스텀 해시 함수 사용

- 데이터의 특성에 맞게 설계된 커스텀 해시 함수를 사용하여 충돌을 최소화

### 참고자료

[[자료구조] Hash/HashTable/HashMap](https://hee96-story.tistory.com/48)

[자료구조 5 - HashMap(해시맵)에 대해 알아보자!](https://velog.io/@cchoijjinyoung/자료구조-5-HashMap해시맵을-알아보자)

[[자료구조] Hash/HashTable/HashMap](https://hee96-story.tistory.com/48)

[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)