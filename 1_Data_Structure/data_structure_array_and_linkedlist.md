# 배열과 연결 리스트

## Array와 LinkedList의 차이가 무엇인가요? (N사 전화면접)

### 1. 접근

- Array : Random Access를 지원. 요소들을 인덱스를 통해 직접 접근할 수 있다. 따라서 특정 요소에 접근하는 시간복잡도는 O(1)이다.
- Linkedlist :  Sequential Access를 지원. 어떤 요소를 접근할 때 순차적으로 검색하며 찾아야 한다. 따라서 특정 요소에 접근할 때 시간복잡도는 O(N)이다.

### 2. 삽입과 삭제

- 배열에서 요소들은 인접한 메모리 위치에 연이어 저장
- Linkedlist에서는 새로운 요소에 할당된 메모리 위치 주소가 linkedlist의 이전 요소에 저장
- 배열에서 삽입과 삭제는 O(N)이 소요되지만, Linkedlist에서 삽입과 삭제는 O(1)이 소요

### 3. 메모리 할당

- 배열에서 메모리는 선언 시, 컴파일 타임에 할당(정적 메모리 할당)
- 반면, Linkedlist에서는 새로운 요소가 추가될 때 런타임에 메모리를 할당(동적 메모리 할당)
- 배열은 Stack 섹션에 메모리 할당이 이루어진다.
- 반면, Linkedlist는 Heap 섹션에 메모리 할당이 이루어진다.

## 배열(Array)

### 정의

**미리 할당된 크기에** 연관된 데이터를 메모리 상에 **연속적으로** 저장하는 **선형 자료구조**

![array_1.png](..%2Fimg%2Farray_1.png)
![https://velog.velcdn.com/images/dlgosla/post/3d29d477-fcbd-4abb-838d-2e68d9797895/image.png](https://velog.velcdn.com/images/dlgosla/post/3d29d477-fcbd-4abb-838d-2e68d9797895/image.png)

### 특징

- 저장 공간이 고정
- 순차적으로 저장
- 인덱스로 원소에 바로 접근할 수 있다.
- 마지막 원소가 아닌 원소를 제거하면 인덱스를 조정하는 shifting이 일어나 O(n)만큼의 시간이 소요
- 컴파일 단계에서 메모리 할당이 발생(정적 메모리 할당)

### 장점

- 인덱스만 알고 있으면 탐색이 매우 빠르다.

### 단점

- 데이터를 처음이나 중간에 삽입/삭제할 때 시간이 오래 걸린다.

  (그 이후의 데이터들을 뒤로 한 칸 씩 shift해야되기 때문에)

- 크기가 고정적이다.

### 시간복잡도

- 인덱스로 탐색: O(1)
- 순차적으로 탐색: O(n)
- 배열의 처음 또는 중간에 삽입 및 삭제: O(n) (삽입 지점 이후의 데이터를 옮겨야 하기 때문)
- 배열의 끝에 삽입 및 삭제: O(1)

---

## 연결 리스트(Linked-List)

### 정의

- **여러 개의 노드들이 순차적으로 연결된 형태**를 갖는 자료구조이다.
- 데이터는 물리적으로 비연속적으로 저장되어있지만, 각 노드들이 다음 노드의 주소를 가리키고 있으므로 논리적으로는 연속적이다.
- 첫번째 노드를 헤드(Head), 마지막 노드를 테일(Tail) 이라고 한다.
- 
![array_2.png](..%2Fimg%2Farray_2.png)
![https://velog.velcdn.com/images/dlgosla/post/603b76c0-7384-4433-be8f-025756d1b282/image.png](https://velog.velcdn.com/images/dlgosla/post/603b76c0-7384-4433-be8f-025756d1b282/image.png)


### 특징

- 런타임 중 데이터(노드)가 추가되는 시점에 메모리가 할당(동적 메모리 할당)
- 배열은 ***데이터 메모리 영역***에 할당되며 연결 리스트는 ***힙 영역***에 할당

### 장점

- 데이터를 차례대로 순회하면서 연산하기 좋다.
- 순회 도중에 새로운 데이터의 삽입,삭제에 용이하다. ( 포인터만 바꿔주면 되니까 )
- 배열과는 달리 데이터의 개수를 모르는 경우에도 별도의 비용 없이 추가할 수 있다.

### 단점

- 반면, 데이터 조회 시 헤드부터 도달하고자 하는 노드까지 순차적으로 접근해야 해서 데이터 조회 속도는 느린 편이다. (랜덤 엑세스 불가능)
- Head 주소를 반드시 기억해야 한다. 그렇지 않으면 탐색이나 삽입/삭제를 수행할 수 없다.

### 시간복잡도

탐색: O(n)

> 삽입 및 삭제: 삽입과 삭제 자체는 O(1) 이다.
연결리스트의 처음에 삽입 및 삭제: O(1)
연결리스트의 중간에 삽입 및 삭제: O(n) (탐색을 해야해서)
>

> 연결리스트의 끝에 삽입 및 삭제:
끝을 가리키는 별도의 포인터를 갖는 경우: O(1)
끝을 가리키는 별도의 포인터를 갖지 않는 경우: O(n) (탐색을 해야해서)
>

> 즉, **탐색은 O(n)**이 걸리고
**처음과 끝**에 삽입이나 삭제를 할 경우 **O(1)**
**중간**에 삽입이나 삭제를 할 경우 탐색이 필요하기 때문에 **O(n)** 이다.
>

---

## 배열 VS 연결 리스트

![array_3.png](..%2Fimg%2Farray_3.png)
![https://velog.velcdn.com/images/dlgosla/post/d807e637-3d2d-47e0-b6ab-4308807daf4c/image.png](https://velog.velcdn.com/images/dlgosla/post/d807e637-3d2d-47e0-b6ab-4308807daf4c/image.png)

데이터 접근이 자주 일어날 때 -> 배열

데이터 수정이 자주 일어날 때 -> 연결 리스트

---

## 이중 연결 리스트

전/후로 탐색이 가능한 구조이다.

즉, 단순 연결 리스트의 노드는 데이터와 다음 노드의 주소를 저장한다면

이중 연결 리스트의 노드는 **데이터, 이전 노드의 주소와 다음 노드의 주소를 저장**하게 된다.

### 장점

- 단순 연결 리스트에서는 최악의 경우 n번의 탐색을 해야 하지만 이중 연결 리스트에서는 얻고자 하는 데이터의 위치가 tail에 가깝다면 tail부터 역방향으로 탐색이 가능하기 때문에 탐색 시간을 줄일 수 있다.

### 단점

- 이전 노드의 주소도 함께 저장해야 하기 때문에 단순 연결 리스트 보다 메모리를 더 많이 잡아 먹는다.

---

## 원형 연결 리스트 (Circular Linked List)

![array_4.png](..%2Fimg%2Farray_4.png)
![https://velog.velcdn.com/images/dlgosla/post/343f8b2c-bffc-4973-a3b3-b35482e7e841/image.png](https://velog.velcdn.com/images/dlgosla/post/343f8b2c-bffc-4973-a3b3-b35482e7e841/image.png)

**마지막 노드가 null을 가리키는 게 아닌 처음 노드를 가리키는 구조**이다.

즉, head부터 순회를 반복적으로 진행하다보면 다시 처음으로 돌아오는 구조이다.

이중 연결 리스트도 마지막 노드가 처음 노드를 가리키는 구조가 되면, 이를 이중 원형 연결 리스트라고 한다.

head와 tail 포인터를 따로 두지 않고 하나의 포인터만 가지고 머리 또는 꼬리에 노드를 추가할 수 있다.

노드를 추가할 때 꼬리에 추가하려면 tail에 추가하고 머리에 추가하고 싶을 땐 tail → next에 추가하면 된다.

### 장점

- head와 tail 포인터를 따로 두지 않고 하나의 포인터만 가지고 머리 또는 꼬리에 노드를 추가할 수 있다.

### 단점

- 구현하는 데 있어서 단순 연결 리스트 보다 복잡해진다.

---

### 참고자료

[[자료구조] 면접질문 모음](https://velog.io/@humblechoi/자료구조-면접질문-모음)

[[CS/자료구조] Array와 LinkedList 정의, 차이점](https://velog.io/@newdana01/CS-Array와-LinkedList-정의-차이점)

[[CS - 자료구조] 배열(Array)과 연결 리스트( Linked List) 관련 개념 정리](https://velog.io/@dlgosla/OS-자료구조-배열Array과-연결-리스트-Linked-List-관련-개념-정리)